# FedRAMP OllaLab - AnyDoc to JSON

## PROPOSED DEVELOPMENT ORDER
Below is the conceptual flow and inter-module dependencies, along with a suggested order in which modules could be developed and tested:
### A. logger_manager.py
- Why First: Logging hooks and error-handling are integral to all other modules. Having a working logger early helps you capture errors during development.  
- Dependencies: None (core utility).  
- Used by: All other modules to centralize logging of successes, failures, and debug messages.
### B. param_manager.py 
- Why Second: Parameter handling is needed at the very beginning (to know which transformations to apply, how to handle file paths, etc.).  
- Dependencies: logger_manager.py (for logging any parameter load or validation errors).  
- Used by: doc_preprocessor (knowing rules for form controls, text removal, anonymization, etc.) and doc_converter (knowing which file to convert). Also used by CLI or Streamlit to load user parameters.
### C. doc_preprocessor.py                                            │
- Why Third: Once parameters are read and validated, you can proceed with text transformations—this is Step 2 of your “Program Steps.”  
- Dependencies:  
    – param_manager.py (to retrieve rules and optional flags—for example, “replaceFormControls,” “removeTexts,” etc.).  
    – logger_manager.py (logging transformations or errors).  
- Used by: doc_converter (the pre-processed docx/PDF is then ready for conversion).
### D. doc_converter.py 
- Why Fourth: After the document has been pre-processed, you convert it (via Docling) into Markdown. This corresponds to Step 3 of the “Program Steps.”  
- Dependencies:  
    – param_manager.py (in case any parameters affect conversion steps or file paths).  
    – logger_manager.py (reporting success/failure).  
    – Potential utility or file manager (optional) for reading/writing files.  
- Used by: md_parser.py (which will process the .md output).
### E. md_parser.py     
- Why Fifth: This module reads the newly generated Markdown file and builds an initial JSON structure per the specified schema. This is Step 4.  
- Dependencies:  
    – logger_manager.py (log parse steps or errors).  
    – Possibly param_manager.py (if there are any toggles that affect how headings/lists/tables are parsed, though it might not be as tightly coupled).  
- Used by: table_processor.py (which refines table data inside this parsed structure).
### F. table_processor.py                                             │
- Why Sixth: After md_parser.py has created the core JSON structure containing raw table data (still in Markdown form or with minimal transformation), you handle the more advanced spanning/merging logic. This is Step 5.  
- Dependencies:  
    – md_parser.py output (structured JSON with “section_table,” “sub_section_table,” etc.).  
    – logger_manager.py.  
- Used by: data_enricher.py (to finalize the table data inside the JSON).
### G. data_enricher.py 
- Why Seventh (Last): This module takes the corrected table data from table_processor.py, identifies key-value pairs, merges them into the final enriched JSON, and saves the result. This is Step 6 in your “Program Steps.”  
- Dependencies:  
    – table_processor.py output.  
    – md_parser.py output (for context outside the tables).  
    – logger_manager.py.  
    – param_manager.py (possibly, if there are parameters controlling how key-value extraction is done).  
### H. The rest of the files
Finally, once these core modules are ready, you can integrate them into:
- anydoc2json_cli.py (the CLI entry point), and  
- main.py / Anydoc_2_Json.py (the Streamlit UI pages),  
